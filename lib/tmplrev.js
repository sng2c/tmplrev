// Generated by CoffeeScript 2.3.2
(function() {
  if (typeof define !== 'function') {
    define = require('amdefine')(module);
  }

  define('tmplrev', ['underscore', 'difflib'], function(_, difflib) {
    var ANY, BOF, EOF, PLACEHOLDER, detect, diff, extract, find, partition, partitionBy;
    PLACEHOLDER = class PLACEHOLDER {
      constructor() {
        this.name = "PLACEHOLDER";
      }

      toString() {
        return `{${this.name}}`;
      }

    };
    PLACEHOLDER = new PLACEHOLDER();
    ANY = Symbol('ANY');
    BOF = Symbol('BOF');
    EOF = Symbol('EOF');
    partition = function(seq, len, step = null) {
      var i, k, ref, ref1, ret, subseq;
      ret = [];
      if (!step || step <= 0) {
        step = len;
      }
      for (i = k = 0, ref = seq.length - len + step, ref1 = step; ref1 !== 0 && (ref1 > 0 ? k < ref : k > ref); i = k += ref1) {
        subseq = seq.slice(i, i + len);
        ret.push(subseq);
      }
      return ret;
    };
    partitionBy = function(seq, val, exclude = false) {
      var begin, end, i, k, ref, ret;
      ret = [];
      begin = end = 0;
      for (i = k = 0, ref = seq.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
        if (_.isEqual(seq[i], val)) {
          if (end > begin) {
            ret.push(seq.slice(begin, end));
          }
          if (!exclude) {
            ret.push(seq.slice(i, i + 1));
          }
          begin = end = i + 1;
        } else {
          end = i + 1;
        }
      }
      if (end > begin) {
        ret.push(seq.slice(begin, end));
      }
      return ret;
    };
    diff = function(a, b) {
      var cur_line, d, dd, k, len1, ret;
      ret = [BOF];
      cur_line = 0;
      dd = difflib.ndiff(a, b);
      for (k = 0, len1 = dd.length; k < len1; k++) {
        d = dd[k];
        if (d[0] === '-') {
          if (_.last(ret) !== ANY) {
            ret.push(ANY);
          }
          cur_line += 1;
        } else if (d[0] === '+') {
          if (_.last(ret) !== ANY) {
            ret.push(ANY);
          }
        } else if (d[0] === '?') {

        } else {
          // pass
          ret.push(a[cur_line]);
          cur_line += 1;
        }
      }
      ret.push(EOF);
      return ret;
    };
    detect = function(a, b, sidelen = 10) {
      var k, len1, p, pat;
      pat = partition(partitionBy(diff(a, b), ANY, true), 2, 1);
      for (k = 0, len1 = pat.length; k < len1; k++) {
        p = pat[k];
        if (p[0].length > sidelen) {
          p[0] = p[0].slice(p[0].length - sidelen, p[0].length);
        }
        if (p[1].length > sidelen) {
          p[1] = p[1].slice(0, sidelen);
        }
      }
      return pat;
    };
    find = function(seq, subseq, offset = 0) {
      var i, j, k, l, matched, ref, ref1, ref2;
      for (i = k = ref = offset, ref1 = seq.length; (ref <= ref1 ? k < ref1 : k > ref1); i = ref <= ref1 ? ++k : --k) {
        matched = true;
        for (j = l = 0, ref2 = subseq.length; (0 <= ref2 ? l < ref2 : l > ref2); j = 0 <= ref2 ? ++l : --l) {
          if (!_.isEqual(seq[i + j], subseq[j])) {
            matched = false;
            break;
          }
        }
        if (matched) {
          return i;
        }
      }
      return -1;
    };
    extract = function(pat, seq) {
      var begin, end, extracted, offset;
      if (typeof seq === "string") {
        seq = seq.split('');
      }
      if (_.first(seq) !== BOF) {
        seq.unshift(BOF);
      }
      if (_.last(seq) !== EOF) {
        seq.push(EOF);
      }
      begin = end = 0;
      extracted = [];
      begin = find(seq, pat[0]);
      // console.log seq, pat[0], begin
      if (begin !== -1) {
        offset = begin + pat[0].length;
        end = find(seq, pat[1], offset);
        if (end !== -1) {
          extracted = seq.slice(offset, end);
        }
      }
      return extracted;
    };
    return {
      ANY: ANY,
      BOF: BOF,
      EOF: EOF,
      PLACEHOLDER: PLACEHOLDER,
      diff: diff,
      partition: partition,
      partitionBy: partitionBy,
      detect: detect,
      extract: extract,
      find: find
    };
  });

}).call(this);
